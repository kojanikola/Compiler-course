MODIFIKACIJA FEBRUAR(swap elemenata niza)
niz = new int[7];
niz[1]=2;
niz[2]=5;
niz~2,1~;
print(niz[1]);//5
print(niz[2]);//2

.lex
"~"          { return new_symbol(sym.SWAP, yytext()); }

.cup
Statement ::= (StatementSwap) Designator SWAP Expr:prvi COMMA Expr:drugi SWAP SEMI;


 public void visit(StatementSwap statementSwap){
        Code.load(statementSwap.getDesignator().obj);
        Code.put(Code.dup_x2);
        Code.put(Code.dup_x1);
        Code.put(Code.pop);
        Code.put(Code.aload);
        Code.load(statementSwap.getDesignator().obj);
        Code.load(statementSwap.getExpr1().obj);
        Code.load(statementSwap.getDesignator().obj);
        Code.load(statementSwap.getExpr().obj);
        Code.put(Code.aload);
        Code.put(Code.astore);
        Code.put(Code.astore);
    }
_____________________________________________________________
MODIFIKACIJA JANUAR
.lex
"@"           {return new_symbol(sym.OPET, yytext());}

.cup
Factor ::= (FactorOpet) Designator OPET NUM;

public void visit(FactorOpet exprOpet){
        Designator a=exprOpet.getDesignator();
        System.out.println(a.obj);
        Code.load(exprOpet.getDesignator().obj);
        Code.load(exprOpet.getDesignator().obj);
        Code.put(Code.arraylength);//skida ime niza i stavlja duzinu
        Code.loadConst(exprOpet.getN2());
        Code.put(Code.sub);
        Code.put(Code.aload);
        Code.load(exprOpet.getDesignator().obj);
        Code.loadConst(exprOpet.getN2());
        Code.put(Code.aload);
        Code.put(Code.add);
    }
	
ExprListOne:
 if (exprListOne.getExpr().getClass()!=ExprTerm.class && exprListOne.getExpr().obj.getKind() == Obj.Elem && !(exprListOne.getExpr().getClass() == ExprAddop.class || termMulop != null)){//od niz 1 niz[1], ostavi samo niz[1] u exprListOne
            Code.put(Code.dup_x2);
            Code.put(Code.pop);
            Code.put(Code.pop);
            Code.put(Code.pop);
        }
_____________________________________________________________
MODIFIKACIJA FEBRUAR GOTO NA LABELU KOJA MOŽE BITI BILO GDE

11. januar 2021 SI - goto i labela, moze da se skoci unapred i unazad u main-u - Januar 2021 SI/Februar 2020

.lex
"goto"      { return new_symbol(sym.GOTO, yytext()); }
":"         { return new_symbol(sym.DOUBLEDOT, yytext()); }

.cup	
StatementList ::= (Statements) StatementList StatementLabel
				  |
				  (NoStmt) /* epsilon */;

StatementLabel ::= (StatementLabel_) LabelList DOUBLEDOT Statement
                    |
                    (StatementNoLabel) Statement;

LabelList ::= (LabelListComma) LabelList COMMA LabelSingle
               |
               (LabelSingleDecl) LabelSingle;

LabelSingle ::= (LabelSingle) IDENT:label;

Label ::= (Label) IDENT:label;

Statement ::= | (StatementJump) GOTO Label:label SEMI;


public ArrayList<Obj> labelsNormal = new ArrayList<Obj>();
    public ArrayList<Obj> labelsGoto = new ArrayList<Obj>();

    public void visit(LabelSingle label) {
        Obj lblGoto = checkLabelGoto(label.getLabel());
        if (lblGoto == null) {
            labelsNormal.add(new Obj(Obj.Con, label.getLabel(), Tab.noType, Code.pc, 0));
            System.out.println("Prepoznata normalna labela:" + label.getLabel());
        } else {
            Code.fixup(lblGoto.getAdr());
        }
    }

    public void visit(Label label) {
        Obj lblNormal = checkLabelNormal(label.getLabel());
        if (lblNormal == null) {
            Code.putJump(0);
            int adr = Code.pc - 2;
            labelsGoto.add(new Obj(Obj.Con, label.getLabel(), Tab.noType, adr, 0));
            System.out.println("Prepoznata GOTO labela:" + label.getLabel());
        } else {
            Code.putJump(lblNormal.getAdr());
        }
    }

    private Obj checkLabelNormal(String name) {
        for (int i = 0; i < labelsNormal.size(); i++) {
            Obj lbl = labelsNormal.get(i);
            if (lbl.getName().equals(name)) {
                return lbl;
            }
        }
        return null;
    }

    private Obj checkLabelGoto(String name) {
        for (int i = 0; i < labelsGoto.size(); i++) {
            Obj lbl = labelsGoto.get(i);
            if (lbl.getName().equals(name)) {
                return lbl;
            }
        }
        return null;
    }
_____________________________________________________________
PRONALAŽENJE MAKSIMUMA NIZA

.lex
"max"       { return new_symbol(sym.MAX, yytext()); }

.cup
Factor ::= | (FactorMax) MAX SWAP Designator SWAP;  //SWAP da ne bi pravilo konflikte, i ne mora

public void visit(FactorMax factorMax) {
        Code.load(factorMax.getDesignator().obj);
        Code.put(Code.dup);
        Code.put(Code.arraylength);//aload
        Code.loadConst(1);
        Code.put(Code.sub);
        Code.put(Code.dup_x1);
        Code.put(Code.aload);

//pocetak petlje
        int adrWhile = Code.pc;
        Code.put(Code.dup_x1);
        Code.put(Code.pop);
        Code.put(Code.dup);
        Code.loadConst(0);
        Code.putFalseJump(Code.gt,0);
        int endWhile = Code.pc-2;

        Code.loadConst(1);
        Code.put(Code.sub);
        Code.load(factorMax.getDesignator().obj);
        Code.put(Code.dup_x1);
        Code.put(Code.pop);
        Code.put(Code.dup_x2);
        Code.put(Code.aload);

        Code.put(Code.dup2);
        Code.putFalseJump(Code.gt,0);
        int elseAdr = Code.pc - 2;
        Code.put(Code.pop);
        Code.putJump(0);
        int thenAdr = Code.pc - 2;
        Code.fixup(elseAdr);
        Code.put(Code.dup_x1);
        Code.put(Code.pop);
        Code.put(Code.pop);
        Code.fixup(thenAdr);

        Code.putJump(adrWhile);
        Code.fixup(endWhile);
//kraj petlje
        Code.put(Code.pop);
        Code.put(Code.dup);
        //Code.put(Code.pop);

    }

[


1. niz = new bool[8]; 
   elementima niza se dodele bool vrednosti i npr. za 
   true false true false false true false true da ispise 165 
   1    0     1    0     0     1    0     1

isto kao max samo sto ne cuvas vrednost nego dodajes siftovanu za n u levo

TRAZI RESENJE

2. niz@1514756673----> ZIZA, "niz" je niz od 4 karaktera 
   1296124481->MAJA 
   1514756673->ZIZA 
   1296124481 - 32b int koji se dodeljuje u elemente niza i ispisuje se od niz[0] do niz[3], na kraju treba da se dobije "ZIZA" ili "MAJA", sa siftovanjem se radi

3. niz@1 = niz[1] + niz[5-1]; gde je 5 arraylength, ova jedinica je NUMBER nije Expr

odradjeno


4. #niz[2] => broj pristupa elementu niza 
   npr. 
   niz[2] = 2;
   niz[1] = niz[2];
   print(#niz[2]); ----> treba da ispise 2

	za factor new 		Code.loadConst(2);
		Code.put(Code.mul);

	public void visit(ExprTaraba exprTaraba) {
		exprTaraba.struct = exprTaraba.getDesignator().obj.getType(); 
	}

				public void visit(DesignatorExpr desExpr) {
		Code.load(desExpr.getDesignatorIdentitet().obj);
		Code.load(desExpr.getDesignatorIdentitet().obj);
		Code.load(desExpr.getDesignatorIdentitet().obj);
		Code.put(Code.arraylength);
		SimpleExpr expr1 = (SimpleExpr) desExpr.getExpr();
		Expr1Term expr1Term = (Expr1Term) expr1.getExpr1();
		TermFactor termFactor1 = (TermFactor) expr1Term.getTerm();
		FactorNumber factorNum1 = (FactorNumber) termFactor1.getFactor();
		Code.loadConst(2);
		Code.put(Code.div);
		Code.loadConst(factorNum1.getN());
		Code.put(Code.add);
		Code.put(Code.dup_x1);
		Code.put(Code.aload);
		Code.loadConst(1);
		Code.put(Code.add);
		Code.put(Code.astore);
	}

			public void visit(ExprTaraba exprTaraba) {
//		DesignatorIdent desI = ((DesignatorExpr)exprTaraba.getDesignator()).getDesignatorIdentitet();
		Code.load(((DesignatorExpr)exprTaraba.getDesignator()).getDesignatorIdentitet().obj);
		DesignatorExpr des = (DesignatorExpr)exprTaraba.getDesignator();
		SimpleExpr simpleExpr = (SimpleExpr) des.getExpr();
		Expr1Term expr1Term = (Expr1Term) simpleExpr.getExpr1();
		TermFactor termFactor = (TermFactor) expr1Term.getTerm();
		FactorNumber factorNum = (FactorNumber) termFactor.getFactor();
		
		Code.load(((DesignatorExpr)exprTaraba.getDesignator()).getDesignatorIdentitet().obj);
		Code.put(Code.arraylength);
		Code.loadConst(2);
		Code.put(Code.div);
		Code.loadConst(factorNum.getN());
		Code.put(Code.add);
		Code.put(Code.aload);
	}

		ucitavas duplo veci niz i te 2. indekse koristis za brojanje

		Expr::=...
			|
			(ExprTaraba) TARABA Designator
			;
		

niz1[0] = niz1@1;
		print(niz1[0]);
		print(niz1[0]);
		print(niz1[1]);
		niz1~1,0~;
		print(niz1[0]);
		print(niz1[1]);

5. niz['a','b','c'] i kad se pozove niz[5]@4 => niz[(5+4)%arraylength]

odradjeno


6. Cezarov algoritam - svako slovo menja sa odg. slovom pomerenim za dati broj npr.

		niz1 = new int[5];
		print(niz1[2]);
		niz1[0] = 0;
		niz1[1] = 1;
		niz1[2] = 2;
		niz1[3] = 3;
		niz1[4] = 4;
		bodovi = niz1[5]#4;
		print(bodovi);
		print(niz1[5]#4);
		niz1[0] = niz1[5]#4;
		print(niz1[0]);
		niz1[0]++;
		print(niz1[0]);
		

7. niz @ - da se ispise max niza -> mislim da je ovo za B modif ipak

odradjeno

8. niz[1,2] - swap-uje niz[1] sa niz[2]

odradjeno

9. dodati final ispred deklaracije niza i omoguciti da se elementima tog niza samo jednom moze dodeliti vrednost - januar 2021 RTI
jedno polje


10. x@y -> x^2 + 2*x*y + y^2
odradjeno

nizch = new char[3];
		nizch[0] = 'a';
		nizch[1] = 'b';
		nizch[5 - 3] = 'c';
		print(nizch[0]);
		cezar(nizch);
		print(nizch[0]);
		print(nizch[1]);
		print(nizch[2]);

